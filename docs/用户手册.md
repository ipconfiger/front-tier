# Pingora 虚拟主机代理使用手册

## 目录

- [项目简介](#项目简介)
- [核心功能](#核心功能)
- [系统架构](#系统架构)
- [环境要求](#环境要求)
- [安装部署](#安装部署)
- [配置说明](#配置说明)
- [API 接口](#api-接口)
- [TLS/SSL 配置指南](#tlsssl-配置指南)
- [AB 测试与灰度发布](#ab-测试与灰度发布)
- [健康检查](#健康检查)
- [监控与指标](#监控与指标)
- [使用示例](#使用示例)
- [故障排查](#故障排查)
- [常见问题](#常见问题)

---

## 项目简介

Pingora 虚拟主机代理是一个基于 Cloudflare Pingora 框架开发的高性能反向代理服务器，专为虚拟主机托管和 AB 测试场景设计。它提供了零停机滚动更新、自动 TLS 证书管理、全面的监控观测等企业级特性。

### 主要特点

- **虚拟主机托管**：在单一代理实例上托管多个域名
- **AB 滚动更新**：支持基于标签的后端版本切换，实现零停机部署
- **标签化路由**：灵活的后端池管理，支持标签分组
- **健康检查**：主动 + 被动健康检查，自动故障转移
- **HTTP 管理 API**：动态配置，无需重启服务
- **Prometheus 指标**：完整的可观测性支持
- **结构化日志**：JSON/文本格式可选，支持日志文件轮转
- **TLS/SSL 支持**：完整的 HTTPS 支持，基于 SNI 的证书选择
- **双证书源**：支持文件证书（nginx 风格）和 Let's Encrypt 自动证书
- **HTTP 到 HTTPS 重定向**：可选的自动重定向增强安全性
- **证书热重载**：更新证书无需停机
- **证书管理 API**：通过 RESTful API 监控和重载证书
- **自动证书续期**：Let's Encrypt 证书自动续期，无需人工干预
- **完整证书链**：自动加载完整证书链，确保 TLS 验证通过

---

## 核心功能

### 1. 虚拟主机管理

支持通过 HTTP API 动态添加、删除、更新域名配置：

```bash
# 添加域名
curl -X POST http://localhost:9090/api/v1/domains \
  -H "Content-Type: application/json" \
  -d '{
    "domain": "example.com",
    "enabled_backends_tag": "a",
    "http_to_https": true
  }'

# 列出所有域名
curl http://localhost:9090/api/v1/domains

# 删除域名
curl -X DELETE http://localhost:9090/api/v1/domains/example.com
```

### 2. 后端服务管理

动态注册和管理后端服务器：

```bash
# 添加后端
curl -X POST http://localhost:9090/api/v1/backends \
  -H "Content-Type: application/json" \
  -d '{
    "id": "web-v1",
    "address": "192.168.1.100:3000",
    "tags": ["a"]
  }'

# 列出所有后端
curl http://localhost:9090/api/v1/backends

# 更新后端
curl -X PUT http://localhost:9090/api/v1/backends/web-v1 \
  -H "Content-Type: application/json" \
  -d '{
    "address": "192.168.1.101:3000"
  }'
```

### 3. AB 测试/灰度发布

一键切换流量，实现零停机灰度发布：

```bash
# 将域名 example.com 的流量从版本 A 切换到版本 B
curl -X POST http://localhost:9090/api/v1/domains/example.com/switch \
  -H "Content-Type: application/json" \
  -d '{"new_tag": "b"}'

# 切换回版本 A
curl -X POST http://localhost:9090/api/v1/domains/example.com/switch \
  -H "Content-Type: application/json" \
  -d '{"new_tag": "a"}'
```

### 4. 健康检查

自动监控后端健康状态，自动剔除不健康的服务器：

- **主动健康检查**：定期向 `/health` 端点发送 HTTP 请求
- **被动健康检查**：基于实际请求的失败率进行检测
- **自动恢复**：不健康的服务器恢复后自动重新加入负载均衡

配置参数：
```toml
[health_check]
interval_secs = 10        # 检查间隔（秒）
timeout_secs = 5          # 超时时间（秒）
unhealthy_threshold = 3   # 不健康阈值（连续失败次数）
healthy_threshold = 2     # 健康阈值（连续成功次数）
```

### 5. Prometheus 指标

内置 Prometheus 监控指标：

- `proxy_requests_total` - 总请求数
- `proxy_request_duration_ms` - 请求延迟（直方图）
- `proxy_active_connections` - 活跃连接数

访问指标端点：
```bash
curl http://localhost:9090/api/v1/metrics
```

### 6. TLS/SSL 证书管理

完整的证书生命周期管理：

**文件证书加载**：
- 支持 nginx 风格的 .crt/.key 文件
- 支持标准的 .pem 格式
- 自动热重载，无需重启

**Let's Encrypt 自动证书**：
- 自动申请和续期
- HTTP-01 挑战验证
- 证书缓存管理

**证书监控 API**：
```bash
# 查看所有证书状态
curl http://localhost:9090/api/v1/certificates

# 手动重载证书
curl -X POST http://localhost:9090/api/v1/certificates/example.com/reload
```

响应示例：
```json
[
  {
    "domain": "example.com",
    "expires_at": "2025-04-15T12:00:00Z",
    "days_until_expiration": 89,
    "source": "file"
  }
]
```

---

## 系统架构

### 组件架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Pingora 虚拟主机代理                         │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────────┐    ┌─────────────┐    ┌──────────────┐  │
│  │ HTTP API 9090│    │  Proxy Core │    │ Metrics 9091 │  │
│  │  管理接口      │───▶│   (Pingora)  │◀───│   Prometheus  │  │
│  └──────────────┘    └─────────────┘    └──────────────┘  │
│         │                                 │                  │
│         │                    ┌─────────────┴──────────────┐   │
│         └───────────────────▶│ Tag-Based Backend Pool    │   │
│                              │ - backend-a1 (tag "a")    │   │
│                              │ - backend-a2 (tag "a")    │   │
│                              │ - backend-b1 (tag "b")    │   │
│                              │ - backend-b2 (tag "b")    │   │
│                              └────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 工作流程

1. **域名路由**：根据请求的 `Host` 头部查找对应的虚拟主机配置
2. **标签选择**：根据虚拟主机的 `enabled_backends_tag` 查找匹配的后端池
3. **健康过滤**：从后端池中过滤掉不健康的服务器
4. **负载均衡**：将请求转发到健康的后端服务器

---

## 环境要求

### 系统要求

- **操作系统**：Linux / macOS / BSD
- **架构**：x86_64 / ARM64
- **内存**：最少 512MB，推荐 2GB+
- **CPU**：2 核心及以上

### 软件依赖

- **Rust**：1.70 或更高版本
- **Git**：用于克隆代码仓库
- **Cargo**：Rust 包管理器（随 Rust 安装）

### 安装 Rust

```bash
# macOS
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Linux
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 验证安装
rustc --version
cargo --version
```

---

## 安装部署

### 方式一：从源码编译

```bash
# 1. 克隆代码仓库
git clone https://github.com/ipconfiger/front-tier.git
cd front-tier

# 2. 编译项目
cargo build --release

# 3. 二进制文件位置
./target/release/pingora-vhost
```

### 方式二：使用 Cargo 直接安装

```bash
cargo install --git https://github.com/ipconfiger/front-tier.git
```

### 创建配置文件

```bash
# 复制示例配置
cp config.example.toml config.toml

# 编辑配置
vim config.toml
```

### 启动服务

```bash
# 开发模式启动
cargo run -- --config config.toml

# 生产模式启动
./target/release/pingora-vhost --config config.toml
```

### 作为系统服务运行（Linux）

创建 systemd 服务文件 `/etc/systemd/system/pingora-vhost.service`：

```ini
[Unit]
Description=Pingora Virtual Host Proxy
After=network.target

[Service]
Type=simple
User=proxy
Group=proxy
WorkingDirectory=/opt/pingora-vhost
ExecStart=/opt/pingora-vhost/pingora-vhost --config /etc/pingora-vhost/config.toml
Restart=always
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

启动服务：

```bash
sudo systemctl daemon-reload
sudo systemctl enable pingora-vhost
sudo systemctl start pingora-vhost
sudo systemctl status pingora-vhost
```

---

## 配置说明

### 完整配置示例

```toml
[proxy]
listen_addr = "0.0.0.0:443"              # HTTPS 监听地址
listen_addr_http = "0.0.0.0:80"         # HTTP 监听地址
management_api_addr = "127.0.0.1:9090"   # 管理 API 地址

[lets_encrypt]                           # Let's Encrypt 配置（计划中）
email = "admin@example.com"
staging = true
cache_dir = "/etc/pingora-ssl/certs"

[logging]                                 # 日志配置
level = "info"                            # 日志级别：trace/debug/info/warn/error
format = "text"                           # 日志格式：text/json
output = "console"                         # 输出目标：console/file
file_path = "/var/log/pingora-proxy/proxy.log"  # 日志文件路径

[metrics]                                 # Prometheus 指标配置
enabled = true
listen_addr = "0.0.0.0:9091"              # 指标服务地址

[health_check]                            # 健康检查配置
interval_secs = 10                        # 检查间隔（秒）
timeout_secs = 5                          # 超时时间（秒）
unhealthy_threshold = 3                   # 不健康阈值
healthy_threshold = 2                     # 健康阈值

[[virtual_hosts]]                        # 虚拟主机列表
domain = "example.com"                    # 域名
enabled_backends_tag = "a"                # 启用的后端标签
http_to_https = true                     # HTTP 自动跳转 HTTPS

[[virtual_hosts]]
domain = "api.example.com"
enabled_backends_tag = "b"

[[backends]]                              # 后端服务器列表
id = "web-v1"                             # 后端 ID
address = "192.168.1.10:3000"             # 后端地址
tags = ["a"]                              # 标签列表

[[backends]]
id = "web-v2"
address = "192.168.1.11:3000"
tags = ["b"]
```

### 配置项说明

#### `[proxy]` 代理配置

| 配置项 | 说明 | 示例值 |
|--------|------|--------|
| `listen_addr` | HTTPS 服务监听地址 | `0.0.0.0:443` |
| `listen_addr_http` | HTTP 服务监听地址（可选） | `0.0.0.0:80` |
| `management_api_addr` | 管理 API 绑定地址 | `127.0.0.1:9090` |

#### `[logging]` 日志配置

| 配置项 | 说明 | 可选值 |
|--------|------|--------|
| `level` | 日志级别 | `trace`, `debug`, `info`, `warn`, `error` |
| `format` | 日志格式 | `text`, `json` |
| `output` | 输出目标 | `console`, `file` |
| `file_path` | 日志文件路径（output=file 时必需） | 任意有效路径 |

#### `[health_check]` 健康检查配置

| 配置项 | 说明 | 默认值 |
|--------|------|--------|
| `interval_secs` | 检查间隔（秒） | 10 |
| `timeout_secs` | 超时时间（秒） | 5 |
| `unhealthy_threshold` | 判定为不健康的连续失败次数 | 3 |
| `healthy_threshold` | 判定为健康的连续成功次数 | 2 |

#### `[[virtual_hosts]]` 虚拟主机配置

| 字段 | 说明 | 必填 |
|------|------|------|
| `domain` | 域名 | 是 |
| `enabled_backends_tag` | 启用的后端标签 | 是 |
| `http_to_https` | 是否自动重定向到 HTTPS | 否（默认 true） |
| `tls_enabled` | 是否启用 TLS | 否（默认 true） |
| `certificate_source` | 证书源配置 | 否 |
| `certificate_source.type` | 证书类型：`file` 或 `lets_encrypt` | 是（配置证书时） |
| `certificate_source.cert_path` | 证书文件路径（type=file 时） | 是 |
| `certificate_source.key_path` | 私钥文件路径（type=file 时） | 是 |

#### `[[backends]]` 后端配置

| 字段 | 说明 | 必填 |
|------|------|------|
| `id` | 后端唯一标识符 | 是 |
| `address` | 后端服务地址（host:port） | 是 |
| `tags` | 标签列表 | 是 |

---

## API 接口

管理 API 默认监听在 `http://127.0.0.1:9090`

### 基础信息

- **Base URL**: `http://127.0.0.1:9090/api/v1`
- **Content-Type**: `application/json`

### 域名管理

#### 获取所有域名

```bash
curl http://127.0.0.1:9090/api/v1/domains
```

**响应示例：**
```json
[
  {
    "domain": "example.com",
    "enabled_backends_tag": "a",
    "http_to_https": true
  }
]
```

#### 添加域名

```bash
curl -X POST http://127.0.0.1:9090/api/v1/domains \
  -H "Content-Type: application/json" \
  -d '{
    "domain": "example.com",
    "enabled_backends_tag": "a",
    "http_to_https": true
  }'
```

**响应：** `201 Created`

#### 获取特定域名

```bash
curl http://127.0.0.1:9090/api/v1/domains/example.com
```

#### 更新域名

```bash
curl -X PUT http://127.0.0.1:9090/api/v1/domains/example.com \
  -H "Content-Type: application/json" \
  -d '{
    "enabled_backends_tag": "b"
  }'
```

#### 删除域名

```bash
curl -X DELETE http://127.0.0.1:9090/api/v1/domains/example.com
```

**响应：** `204 No Content`

#### AB 切换（切换后端标签）

```bash
curl -X POST http://127.0.0.1:9090/api/v1/domains/example.com/switch \
  -H "Content-Type: application/json" \
  -d '{"new_tag": "b"}'
```

**响应：** `200 OK`

### 后端管理

#### 获取所有后端

```bash
curl http://127.0.0.1:9090/api/v1/backends
```

**响应示例：**
```json
[
  {
    "id": "web-v1",
    "address": "192.168.1.10:3000",
    "tags": ["a"]
  }
]
```

#### 添加后端

```bash
curl -X POST http://127.0.0.1:9090/api/v1/backends \
  -H "Content-Type: application/json" \
  -d '{
    "id": "web-v1",
    "address": "192.168.1.10:3000",
    "tags": ["a"]
  }'
```

**响应：** `201 Created`

#### 获取特定后端

```bash
curl http://127.0.0.1:9090/api/v1/backends/web-v1
```

#### 更新后端

```bash
curl -X PUT http://127.0.0.1:9090/api/v1/backends/web-v1 \
  -H "Content-Type: application/json" \
  -d '{
    "address": "192.168.1.11:3000"
  }'
```

#### 删除后端

```bash
curl -X DELETE http://127.0.0.1:9090/api/v1/backends/web-v1
```

**响应：** `204 No Content`

### 监控与观测

#### 健康检查

```bash
curl http://127.0.0.1:9090/api/v1/health
```

**响应：** `OK`

#### Prometheus 指标

```bash
curl http://127.0.0.1:9090/api/v1/metrics
```

**响应示例：**
```
# HELP proxy_requests_total Total number of requests
# TYPE proxy_requests_total counter
proxy_requests_total 1234
# HELP proxy_request_duration_ms Request duration in milliseconds
# TYPE proxy_request_duration_ms histogram
...
```

### 证书管理

#### 查看所有证书

```bash
curl http://127.0.0.1:9090/api/v1/certificates
```

**响应示例：**
```json
[
  {
    "domain": "example.com",
    "expires_at": "2025-04-15T12:00:00Z",
    "days_until_expiration": 89,
    "source": "file"
  },
  {
    "domain": "api.example.com",
    "expires_at": "2025-03-20T08:30:00Z",
    "days_until_expiration": 63,
    "source": "lets_encrypt"
  }
]
```

#### 手动重载证书

```bash
curl -X POST http://127.0.0.1:9090/api/v1/certificates/example.com/reload
```

**响应：**
```json
{
  "message": "Certificate reloaded successfully for domain: example.com",
  "domain": "example.com"
}
```

**注意：** 证书文件修改后会自动热重载，此接口用于特殊情况下的手动重载。

---

## TLS/SSL 配置指南

### 证书源类型

代理支持两种证书源：

#### 1. 文件证书（File-based）

使用现有的证书文件（nginx 风格）：

```toml
[[virtual_hosts]]
domain = "secure.example.com"
enabled_backends_tag = "a"
http_to_https = true
tls_enabled = true
[virtual_hosts.certificate_source]
type = "file"
cert_path = "/etc/ssl/certs/secure.example.com.crt"
key_path = "/etc/ssl/private/secure.example.com.key"
```

**支持的文件格式：**
- 证书：`.crt`, `.pem`, `.cer`
- 私钥：`.key`, `.pem`（未加密或 PKCS#8）

**文件权限要求：**
```bash
# 证书文件：可读
chmod 644 /etc/ssl/certs/secure.example.com.crt

# 私钥文件：仅所有者可读
chmod 600 /etc/ssl/private/secure.example.com.key

# 确保证书和密钥匹配
openssl x509 -noout -modulus -in /path/to/cert.crt | openssl md5
openssl rsa -noout -modulus -in /path/to/key.key | openssl md5
# 两个命令的输出应该相同
```

**自签名证书生成（用于测试）：**
```bash
# 生成私钥
openssl genrsa -out server.key 2048

# 生成证书签名请求（CSR）
openssl req -new -key server.key -out server.csr

# 生成自签名证书（有效期 365 天）
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
```

#### 2. Let's Encrypt 自动证书

自动申请、续期证书：

```toml
[lets_encrypt]
email = "admin@example.com"           # 用于接收证书过期提醒
staging = true                        # 测试环境使用 staging，生产环境设为 false
cache_dir = "/etc/pingora-ssl/certs"
renewal_check_interval_secs = 86400   # 检查间隔（秒），默认 86400（每天）
renewal_days_before_expiry = 30       # 提前几天续期，默认 30 天

[[virtual_hosts]]
domain = "auto-secure.example.com"
enabled_backends_tag = "a"
http_to_https = true
tls_enabled = true
[virtual_hosts.certificate_source]
type = "lets_encrypt"
```

**自动证书续期：**

Let's Encrypt 证书会在过期前自动续期：

- 后台任务定期检查证书过期时间（默认：每天）
- 证书进入续期窗口后自动申请新证书（默认：30 天前）
- 续期后的证书自动加载，无需重启服务
- 只有 Let's Encrypt 证书会自动续期（文件证书会显示警告）

**示例配置：提前 1 天续期**
```toml
[lets_encrypt]
email = "admin@example.com"
staging = false
cache_dir = "/etc/pingora-ssl/certs"
renewal_check_interval_secs = 86400  # 每 24 小时检查一次
renewal_days_before_expiry = 1       # 提前 1 天续期
```

**使用条件：**
1. 域名 DNS 必须指向代理服务器
2. 端口 80 必须可从互联网访问（用于 HTTP-01 挑战）
3. 未达到 Let's Encrypt 速率限制：
   - 测试环境（staging）：无严格限制
   - 生产环境：每域名每周 50 个证书

**证书申请流程：**
1. 代理启动后自动向 Let's Encrypt 申请证书
2. Let's Encrypt 发送 HTTP-01 挑战请求到 `http://your-domain.com/.well-known/acme-challenge/{token}`
3. 代理自动响应挑战
4. 证书颁发并缓存到 `cache_dir`
5. 后台任务定期检查，在过期前自动续期

**验证 Let's Encrypt 配置：**
```bash
# 1. 检查 DNS 解析
dig +short your-domain.com

# 2. 检查端口 80 可达性
curl -I http://your-domain.com

# 3. 测试 ACME 挑战端点
curl http://your-domain.com/.well-known/acme-challenge/test

# 4. 查看代理日志
tail -f /var/log/pingora-proxy/proxy.log | grep -i acme
```

### HTTP 到 HTTPS 自动重定向

自动将 HTTP 流量重定向到 HTTPS：

```toml
[[virtual_hosts]]
domain = "example.com"
enabled_backends_tag = "a"
http_to_https = true  # 启用自动重定向
```

**工作原理：**
1. 客户端访问 `http://example.com/path`
2. 代理返回 `301 Moved Permanently`
3. Location 头部设置为 `https://example.com/path`
4. 客户端自动跟随重定向到 HTTPS
5. SNI 路由正常工作

**测试重定向：**
```bash
# 应该看到 301 重定向
curl -I http://example.com

# 输出示例：
# HTTP/1.1 301 Moved Permanently
# Location: https://example.com/
```

### SNI 多证书路由

基于 TLS Server Name Indication (SNI) 自动选择证书：

```toml
# 每个域名使用不同的证书
[[virtual_hosts]]
domain = "example.com"
enabled_backends_tag = "web"
[virtual_hosts.certificate_source]
type = "file"
cert_path = "/etc/ssl/certs/example.com.crt"
key_path = "/etc/ssl/private/example.com.key"

[[virtual_hosts]]
domain = "api.example.com"
enabled_backends_tag = "api"
[virtual_hosts.certificate_source]
type = "lets_encrypt"

[[virtual_hosts]]
domain = "blog.example.com"
enabled_backends_tag = "blog"
[virtual_hosts.certificate_source]
type = "file"
cert_path = "/etc/ssl/certs/blog.com.crt"
key_path = "/etc/ssl/private/blog.com.key"
```

**SNI 工作流程：**
1. 客户端发起 TLS 握手
2. ClientHello 消息包含目标域名（SNI 扩展）
3. 代理根据 SNI 选择对应证书
4. 使用选定证书完成 TLS 握手
5. 解密后的 HTTP 请求根据 `Host` 头部路由

**验证 SNI 证书选择：**
```bash
# 测试 example.com 的证书
openssl s_client -connect example.com:443 -servername example.com | openssl x509 -noout -subject

# 测试 api.example.com 的证书
openssl s_client -connect api.example.com:443 -servername api.example.com | openssl x509 -noout -subject
```

### 证书热重载

证书文件修改后自动重载，无需重启代理：

**工作原理：**
1. 文件监控器（notify）监听证书文件变化
2. 检测到文件修改时触发重载
3. 新证书无缝替换旧证书
4. 现有连接使用旧证书直到关闭
5. 新连接使用新证书

**手动触发重载：**
```bash
curl -X POST http://127.0.0.1:9090/api/v1/certificates/example.com/reload
```

**验证证书重载：**
```bash
# 1. 查看证书过期时间
curl -s http://127.0.0.1:9090/api/v1/certificates | jq '.[] | select(.domain=="example.com")'

# 2. 替换证书文件
cp new-cert.crt /etc/ssl/certs/example.com.crt

# 3. 查看代理日志
tail -f /var/log/pingora-proxy/proxy.log | grep "Certificate reloaded"

# 4. 验证新证书生效
openssl s_client -connect example.com:443 | openssl x509 -noout -dates
```

### 证书过期监控

通过 API 监控证书过期时间：

```bash
# 查看所有证书
curl http://127.0.0.1:9090/api/v1/certificates

# 筛选即将过期的证书（30 天内）
curl -s http://127.0.0.1:9090/api/v1/certificates | \
  jq '.[] | select(.days_until_expiration < 30)'

# 设置定时监控（每小时检查一次）
watch -n 3600 'curl -s http://127.0.0.1:9090/api/v1/certificates | \
  jq ".[] | select(.days_until_expiration < 30)"'
```

**Prometheus 告警规则示例：**
```yaml
groups:
  - name: certificate_alerts
    rules:
      - alert: CertificateExpiringSoon
        expr: |
          certificate_days_until_expiration < 30
        for: 1h
        labels:
          severity: warning
        annotations:
          summary: "Certificate for {{ $labels.domain }} expiring in {{ $value }} days"
```

### 完整配置示例

**场景：** 多域名 HTTPS 代理，混合使用文件证书和 Let's Encrypt

```toml
[proxy]
listen_addr = "0.0.0.0:443"
listen_addr_http = "0.0.0.0:80"
management_api_addr = "127.0.0.1:9090"

[lets_encrypt]
email = "admin@example.com"
staging = false
cache_dir = "/etc/pingora-ssl/certs"

[logging]
level = "info"
format = "json"
output = "file"
file_path = "/var/log/pingora-proxy/proxy.log"

[metrics]
enabled = true
listen_addr = "0.0.0.0:9091"

[health_check]
interval_secs = 10
timeout_secs = 5
unhealthy_threshold = 3
healthy_threshold = 2

# 主站 - 使用文件证书
[[virtual_hosts]]
domain = "example.com"
enabled_backends_tag = "main"
http_to_https = true
tls_enabled = true
[virtual_hosts.certificate_source]
type = "file"
cert_path = "/etc/ssl/certs/example.com.crt"
key_path = "/etc/ssl/private/example.com.key"

# API - 使用 Let's Encrypt
[[virtual_hosts]]
domain = "api.example.com"
enabled_backends_tag = "api"
http_to_https = true
tls_enabled = true
[virtual_hosts.certificate_source]
type = "lets_encrypt"

# 博客 - 使用文件证书
[[virtual_hosts]]
domain = "blog.example.com"
enabled_backends_tag = "blog"
http_to_https = true
tls_enabled = true
[virtual_hosts.certificate_source]
type = "file"
cert_path = "/etc/ssl/certs/blog.com.crt"
key_path = "/etc/ssl/private/blog.com.key"

# 主站后端
[[backends]]
id = "web-1"
address = "10.0.1.10:80"
tags = ["main"]

[[backends]]
id = "web-2"
address = "10.0.1.11:80"
tags = ["main"]

# API 后端
[[backends]]
id = "api-1"
address = "10.0.2.10:8080"
tags = ["api"]

# 博客后端
[[backends]]
id = "blog-1"
address = "10.0.3.10:80"
tags = ["blog"]
```

---

## AB 测试与灰度发布

### 标签化路由原理

基于标签的后端池管理是本代理的核心特性。每个后端服务器可以拥有多个标签，域名通过标签来选择要路由到的后端池。

**示例架构：**

```
版本 A（生产环境）
├── backend-a1 (192.168.1.10:3000) [tags: a, production]
└── backend-a2 (192.168.1.11:3000) [tags: a, production]

版本 B（金丝雀版本）
├── backend-b1 (192.168.1.20:3000) [tags: b, canary]
└── backend-b2 (192.168.1.21:3000) [tags: b, canary]

域名配置：
example.com → enabled_backends_tag = "a"  # 流量指向版本 A
```

### AB 测试完整流程

#### 1. 准备两个版本的后端

假设你有两个版本的应用已经部署：

**版本 A（稳定版本）：**
- 端口：3001, 3002
- 标签：`["a", "stable"]`

**版本 B（新版本）：**
- 端口：3003, 3004
- 标签：`["b", "canary"]`

#### 2. 注册后端服务器

```bash
# 注册版本 A 的后端
curl -X POST http://127.0.0.1:9090/api/v1/backends \
  -H "Content-Type: application/json" \
  -d '{
    "id": "app-v1-1",
    "address": "192.168.1.10:3001",
    "tags": ["a", "stable"]
  }'

curl -X POST http://127.0.0.1:9090/api/v1/backends \
  -H "Content-Type: application/json" \
  -d '{
    "id": "app-v1-2",
    "address": "192.168.1.11:3002",
    "tags": ["a", "stable"]
  }'

# 注册版本 B 的后端
curl -X POST http://127.0.0.1:9090/api/v1/backends \
  -H "Content-Type: application/json" \
  -d '{
    "id": "app-v2-1",
    "address": "192.168.1.20:3003",
    "tags": ["b", "canary"]
  }'

curl -X POST http://127.0.0.1:9090/api/v1/backends \
  -H "Content-Type: application/json" \
  -d '{
    "id": "app-v2-2",
    "address": "192.168.1.21:3004",
    "tags": ["b", "canary"]
  }'
```

#### 3. 配置域名使用版本 A

```bash
curl -X POST http://127.0.0.1:9090/api/v1/domains \
  -H "Content-Type: application/json" \
  -d '{
    "domain": "example.com",
    "enabled_backends_tag": "a",
    "http_to_https": true
  }'
```

此时所有访问 `example.com` 的流量都会路由到版本 A 的服务器。

#### 4. 灰度发布 - 切换 10% 流量到版本 B

有两种方式：

**方式 1：标签策略**

为新版本添加共享标签：

```bash
# 更新版本 B 的后端，同时添加 "a" 标签
curl -X PUT http://127.0.0.1:9090/api/v1/backends/app-v2-1 \
  -H "Content-Type: application/json" \
  -d '{
    "tags": ["b", "canary", "a"]
  }'
```

此时标签 "a" 包含：
- app-v1-1 (版本 A)
- app-v1-2 (版本 A)
- app-v2-1 (版本 B)

流量会均匀分布到所有 3 个后端，版本 B 获得约 33% 流量（可通过调整后端数量控制比例）。

**方式 2：独立金丝雀标签**

创建专门的金丝雀域名：

```bash
# 创建金丝雀域名
curl -X POST http://127.0.0.1:9090/api/v1/domains \
  -H "Content-Type: application/json" \
  -d '{
    "domain": "canary.example.com",
    "enabled_backends_tag": "b",
    "http_to_https": true
  }'
```

- `example.com` → 标签 "a"（版本 A，所有用户）
- `canary.example.com` → 标签 "b"（版本 B，内部测试用户）

#### 5. 完全切换到版本 B

```bash
# 验证版本 B 健康状态
curl http://192.168.1.20:3003/health
curl http://192.168.1.21:3004/health

# 执行切换
curl -X POST http://127.0.0.1:9090/api/v1/domains/example.com/switch \
  -H "Content-Type: application/json" \
  -d '{"new_tag": "b"}'
```

**响应：**
```json
{
  "domain": "example.com",
  "enabled_backends_tag": "b",
  "http_to_https": true
}
```

#### 6. 回滚（如果需要）

如果版本 B 发现问题，立即回滚：

```bash
curl -X POST http://127.0.0.1:9090/api/v1/domains/example.com/switch \
  -H "Content-Type: application/json" \
  -d '{"new_tag": "a"}'
```

所有流量立即切换回版本 A，无需重启服务。

### 灰度发布最佳实践

1. **逐步放量**：先小范围测试，再逐步扩大
   - 5% → 10% → 25% → 50% → 100%

2. **监控指标**：密切关注错误率、响应时间
   ```bash
   # 实时监控
   watch -n 5 'curl -s http://127.0.0.1:9090/api/v1/metrics | grep proxy_requests_total'
   ```

3. **保留旧版本**：回滚方案始终就绪
   - 不要立即删除旧版本的后端
   - 至少保留到确认新版本完全稳定

4. **日志分析**：检查新版本日志，确认无异常
   ```bash
   # 查看实时日志
   tail -f /var/log/pingora-proxy/proxy.log
   ```

---

## 健康检查

### 主动健康检查

代理会定期向后端的 `/health` 端点发送 HTTP GET 请求。

**后端健康检查端点要求：**

```json
{
  "status": "healthy",
  "backend_id": "app-v1"
}
```

**健康检查流程：**

1. 后端注册后立即开始健康检查
2. 连续 2 次成功 → 标记为健康
3. 连续 3 次失败 → 标记为不健康
4. 不健康的后端不会接收流量
5. 不健康的后端仍会继续被检查，恢复后自动重新加入

**查看后端健康状态：**

健康状态会自动影响路由决策，但也可以通过以下方式监控：

```bash
# 查看后端列表（不包含健康状态）
curl http://127.0.0.1:9090/api/v1/backends

# 查看 Prometheus 指标（包含健康检查相关的指标）
curl http://127.0.0.1:9090/api/v1/metrics | grep health_check
```

---

## 监控与指标

### Prometheus 集成

#### 配置 Prometheus

在 `prometheus.yml` 中添加抓取目标：

```yaml
scrape_configs:
  - job_name: 'pingora-proxy'
    static_configs:
      - targets: ['localhost:9090']
    metrics_path: '/api/v1/metrics'
    scrape_interval: 15s
```

#### 启动 Prometheus

```bash
docker run -d \
  -p 9091:9091 \
  -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

#### Grafana 仪表板

推荐创建的 Grafana 面板：

1. **请求速率监控**
   - 面板标题：请求 QPS
   - 查询：`rate(proxy_requests_total[1m])`

2. **错误率监控**
   - 面板标题：请求错误率
   - 查询：`sum(rate(proxy_requests_total{error="true"}[5m])) / sum(rate(proxy_requests_total[5m]))`

3. **响应时间分布**
   - 面板标题：P99 响应时间
   - 查询：`histogram_quantile(0.99, rate(proxy_request_duration_ms_bucket[5m]))`

4. **活跃连接数**
   - 面板标题：活跃连接
   - 查询：`proxy_active_connections`

### 关键指标说明

| 指标名称 | 类型 | 说明 |
|---------|------|------|
| `proxy_requests_total` | Counter | 请求总数（累计） |
| `proxy_request_duration_ms` | Histogram | 请求耗时分布 |
| `proxy_active_connections` | Gauge | 当前活跃连接数 |

---

## 使用示例

### 示例 1：基本的反向代理

**场景：** 将 `example.com` 的流量转发到本地后端服务

**配置：**
```toml
[[virtual_hosts]]
domain = "example.com"
enabled_backends_tag = "prod"

[[backends]]
id = "web-server"
address = "127.0.0.1:8080"
tags = ["prod"]
```

**启动代理：**
```bash
cargo run -- --config config.toml
```

**测试：**
```bash
# 访问域名（通过 hosts 文件映射到 127.0.0.1）
curl http://example.com/
```

### 示例 2：多域名虚拟主机

**场景：** 同时托管多个网站

**配置：**
```toml
[[virtual_hosts]]
domain = "example.com"
enabled_backends_tag = "example-backends"

[[virtual_hosts]]
domain = "api.example.com"
enabled_backends_tag = "api-backends"

[[virtual_hosts]]
domain = "blog.example.com"
enabled_backends_tag = "blog-backends"

[[backends]]
id = "example-web"
address = "10.0.1.10:80"
tags = ["example-backends"]

[[backends]]
id = "api-server"
address = "10.0.2.10:8080"
tags = ["api-backends"]
```

### 示例 3：零停机部署

**场景：** 更新应用版本而不中断服务

**步骤：**

1. **部署新版本**（版本 B）到新服务器
   ```bash
   # 注册新版本后端
   curl -X POST http://127.0.0.1:9090/api/v1/backends \
     -H "Content-Type: application/json" \
     -d '{
       "id": "app-v2",
       "address": "10.0.1.20:3000",
       "tags": ["b"]
     }'
   ```

2. **验证新版本健康**
   ```bash
   curl http://10.0.1.20:3000/health
   ```

3. **切换流量**
   ```bash
   curl -X POST http://127.0.0.1:9090/api/v1/domains/example.com/switch \
     -H "Content-Type: application/json" \
     -d '{"new_tag": "b"}'
   ```

4. **观察日志**
   ```bash
   # 查看切换日志
   tail -f /var/log/pingora-proxy/proxy.log | grep "Switched backend tag"
   ```

5. **确认无问题后移除旧版本**
   ```bash
   curl -X DELETE http://127.0.0.1:9090/api/v1/backends/app-v1
   ```

---

## 故障排查

### TLS/SSL 证书问题

#### 1. 证书加载失败

**症状：** 代理启动时提示 "certificate not found" 或无法加载证书

**排查步骤：**
```bash
# 1. 验证证书文件存在
ls -l /etc/ssl/certs/example.com.crt
ls -l /etc/ssl/private/example.com.key

# 2. 检查文件权限
# 证书文件应可读（644）
# 私钥文件应仅所有者可读（600）
stat /etc/ssl/certs/example.com.crt
stat /etc/ssl/private/example.com.key

# 3. 验证证书格式
openssl x509 -in /etc/ssl/certs/example.com.crt -text -noout

# 4. 验证私钥格式
openssl rsa -in /etc/ssl/private/example.com.key -check -noout

# 5. 确保证书和私钥匹配
openssl x509 -noout -modulus -in /etc/ssl/certs/example.com.crt | openssl md5
openssl rsa -noout -modulus -in /etc/ssl/private/example.com.key | openssl md5
# 两个命令的输出应该相同
```

**解决方案：**
1. 修正文件路径（确保配置文件中的路径正确）
2. 调整文件权限：
   ```bash
   chmod 644 /etc/ssl/certs/example.com.crt
   chmod 600 /etc/ssl/private/example.com.key
   chown proxy-user:proxy-user /etc/ssl/private/example.com.key
   ```
3. 重新生成证书（如果证书损坏）

#### 2. SNI 路由错误

**症状：** 访问域名时显示错误的证书

**排查步骤：**
```bash
# 1. 检查虚拟主机配置
curl http://127.0.0.1:9090/api/v1/domains

# 2. 测试 SNI 证书选择
openssl s_client -connect example.com:443 -servername example.com | \
  openssl x509 -noout -subject | grep subject

# 3. 验证 DNS 解析
dig +short example.com
nslookup example.com

# 4. 检查是否有多个域名指向同一 IP
```

**解决方案：**
1. 确认虚拟主机配置中的域名与请求域名完全匹配
2. 检查 DNS 配置，确保域名解析到正确的 IP
3. 验证配置文件中该域名的 `certificate_source` 配置正确
4. 重新加载配置

#### 3. Let's Encrypt 证书申请失败

**症状：** 自动证书申请失败，日志中出现 ACME 错误

**排查步骤：**
```bash
# 1. 检查代理日志（查找 ACME 相关错误）
tail -f /var/log/pingora-proxy/proxy.log | grep -i "acme\|let's encrypt\|challenge"

# 2. 验证 DNS 解析
dig +short your-domain.com
# 应该返回代理服务器的 IP

# 3. 测试 HTTP-01 挑战端点
curl -I http://your-domain.com/.well-known/acme-challenge/test

# 4. 检查端口 80 是否可从外网访问
# 从外部机器测试
telnet your-domain.com 80

# 5. 检查防火墙规则
sudo iptables -L -n | grep 80
sudo ufw status
```

**常见错误及解决方案：**

**错误 1：** "Connection refused" 或 "Timeout"
- **原因：** 端口 80 被防火墙阻止
- **解决：** 开放端口 80：
  ```bash
  # ufw
  sudo ufw allow 80/tcp

  # iptables
  sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
  ```

**错误 2：** "Invalid domain" 或 "Domain not found"
- **原因：** DNS 未正确配置
- **解决：**
  1. 等待 DNS 传播（最多 48 小时）
  2. 使用 `dig` 验证 DNS 解析
  3. 配置正确的 A 记录指向代理服务器 IP

**错误 3：** "Rate limited"
- **原因：** 超过 Let's Encrypt 速率限制
- **解决：**
  1. 检查是否已达到限制（生产环境：50 个证书/域名/周）
  2. 使用 staging 环境测试（`staging = true`）
  3. 等待限制重置（每周一重置）

**错误 4：** "Challenge failed"
- **原因：** HTTP-01 挑战响应失败
- **解决：**
  1. 确认端口 80 可访问
  2. 检查是否有其他服务占用端口 80
  3. 验证 `http_to_https` 配置（ACME 挑战需要 HTTP）

#### 4. 证书过期未续期

**症状：** 证书过期后未自动续期

**排查步骤：**
```bash
# 1. 检查证书过期时间
curl http://127.0.0.1:9090/api/v1/certificates | jq

# 2. 查看 Let's Encrypt 续期日志
tail -f /var/log/pingora-proxy/proxy.log | grep -i "renew\|expire"

# 3. 验证 Let's Encrypt 配置
# 检查配置文件中的 [lets_encrypt] 部分

# 4. 测试续期流程
# 代理会在证书到期前 30 天自动续期
```

**解决方案：**
1. **手动重载证书**（如果已更新文件）：
   ```bash
   curl -X POST http://127.0.0.1:9090/api/v1/certificates/example.com/reload
   ```

2. **检查续期任务**：
   - 确认代理持续运行
   - 检查日志中的续期任务错误

3. **强制重新申请证书**（删除旧证书后重启代理）：
   ```bash
   rm /etc/pingora-ssl/certs/example.com.*
   systemctl restart pingora-vhost
   ```

#### 5. 证书热重载不生效

**症状：** 更新证书文件后，代理仍使用旧证书

**排查步骤：**
```bash
# 1. 检查文件监控器是否运行
# 查看代理日志中的文件监控相关消息
tail -f /var/log/pingora-proxy/proxy.log | grep -i "watch\|reload\|certificate"

# 2. 验证文件确实已更新
stat /etc/ssl/certs/example.com.crt
ls -l /etc/ssl/certs/example.com.crt

# 3. 测试文件系统事件
# Linux
inotifywait -m /etc/ssl/certs/

# macOS
# 文件监控使用 FSEvents，无需额外工具
```

**解决方案：**
1. **手动触发重载**：
   ```bash
   curl -X POST http://127.0.0.1:9090/api/v1/certificates/example.com/reload
   ```

2. **验证新证书内容**：
   ```bash
   # 查看当前证书
   openssl s_client -connect example.com:443 | openssl x509 -noout -dates
   ```

3. **检查文件权限**：文件监控器需要读取权限

4. **重启代理**（最后手段）：
   ```bash
   systemctl restart pingora-vhost
   ```

#### 6. 混合内容警告

**症状：** 浏览器显示 "Mixed Content" 警告

**原因：** HTTPS 页面中包含 HTTP 资源

**解决方案：**
1. 确保所有资源使用 HTTPS：
   ```html
   <!-- 错误 -->
   <script src="http://cdn.example.com/script.js"></script>
   <img src="http://images.example.com/logo.png">

   <!-- 正确 -->
   <script src="https://cdn.example.com/script.js"></script>
   <img src="https://images.example.com/logo.png">

   <!-- 或使用协议相对 URL -->
   <script src="//cdn.example.com/script.js"></script>
   ```

2. 配置后端应用使用 HTTPS
3. 启用 `http_to_https` 重定向

### 常见问题

#### 1. 代理启动失败

**症状：** 启动时提示配置错误

**解决方案：**
```bash
# 验证配置文件
cargo run -- --config config.toml

# 检查端口占用
lsof -i :8080
lsof -i :9090
```

#### 2. 后端无法访问

**症状：** 返回 502 Bad Gateway

**排查步骤：**
```bash
# 1. 检查后端是否运行
curl http://backend-ip:port/health

# 2. 检查网络连通性
ping backend-ip
telnet backend-ip port

# 3. 查看代理日志
tail -f /var/log/pingora-proxy/proxy.log

# 4. 查看后端列表
curl http://127.0.0.1:9090/api/v1/backends
```

#### 3. AB 切换不生效

**症状：** 切换后流量仍然路由到旧版本

**解决方案：**
```bash
# 1. 验证切换结果
curl http://127.0.0.1:9090/api/v1/domains/example.com

# 2. 确认新版本后端存在且健康
curl http://127.0.0.1:9090/api/v1/backends | jq '.[] | select(.tags | index("b"))'

# 3. 检查健康检查配置
curl http://127.0.0.1:9090/api/v1/metrics | grep health_check
```

#### 4. 健康检查失败

**症状：** 所有后端被标记为不健康

**排查步骤：**
```bash
# 1. 手动测试后端健康端点
curl http://backend-ip:port/health

# 2. 检查健康检查配置
# 查看 config.toml 中的 [health_check] 部分

# 3. 调整阈值
# 增加失败阈值、减少成功阈值
```

### 日志调试

启用调试日志：

```toml
[logging]
level = "debug"
format = "text"
output = "console"
```

重启代理后将看到详细的调试信息。

---

## 常见问题

### Q1：如何实现负载均衡？

**A：** 当前实现采用简单的轮询负载均衡（由 Pingora 框架提供）。同一标签下的所有健康后端平均分配流量。

### Q2：支持 WebSocket 吗？

**A：** 需要在完整 Pingora 集成后支持。当前版本是代理骨架，WebSocket 支持在 TODO 列表中。

### Q3：如何实现会话保持（Sticky Session）？

**A：** 可以通过标签策略实现：

```bash
# 用户 A 的会话路由到后端 1
# 为该用户分配专用域名或标签
```

完整实现需要在 Pingora 层配置会话保持。

### Q4：支持 HTTPS 证书吗？

**A：** 配置文件包含 Let's Encrypt 配置项，但证书管理功能仍在开发中。目前需要手动配置证书并放在指定目录。

### Q5：如何配置多个管理 API 用户？

**A：** 当前版本未实现身份验证。管理 API 监听在 `127.0.0.1`，仅本机可访问。生产环境建议：

1. 使用防火墙限制访问
2. 配置反向代理（如 nginx）并添加 Basic Auth
3. 等待官方身份验证功能实现

### Q6：如何备份和恢复配置？

**A：** 所有配置都在 `config.toml` 文件中。只需备份此文件即可：

```bash
# 备份配置
cp config.toml config.toml.backup

# 恢复配置
cp config.toml.backup config.toml
```

### Q7：支持动态配置热加载吗？

**A：** 是的！通过 HTTP API 进行的所有配置更改（域名、后端、标签切换）都会立即生效，无需重启服务。

---

## 附录

### 测试后端服务器

项目包含一个 Python 测试后端服务器，用于测试代理功能：

```bash
# 启动测试后端
python3 test_backend.py 9527 backend-a

# 访问健康检查
curl http://localhost:9527/health
```

### 性能调优建议

1. **增加工作进程**：通过 systemd `LimitCPU` 配置
2. **调整文件描述符限制**：`ulimit -n 65535`
3. **启用 HTTP/2**：在 Pingora 集成时配置
4. **配置连接池**：调整后端连接池大小

### 技术支持

- **GitHub**: https://github.com/ipconfiger/front-tier
- **Issues**: https://github.com/ipconfiger/front-tier/issues
- **文档**: 完整技术文档请参见 `CLAUDE.md`

---

**版本：** v0.1.0
**更新日期：** 2026-01-17
**许可证：** MIT
